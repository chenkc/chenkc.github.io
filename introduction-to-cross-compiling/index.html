<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Introduction to cross-compiling - chenkc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="refer: Original link
ref: http://landley.net/writing/docs/cross-compiling.html
Host vs TargetA compiler is a program that turns source code into executable code. Like all programs, a compiler runs on">
<meta property="og:type" content="article">
<meta property="og:title" content="Introduction to cross-compiling">
<meta property="og:url" content="http://chenkc.github.io/introduction-to-cross-compiling/index.html">
<meta property="og:site_name" content="chenkc">
<meta property="og:description" content="refer: Original link
ref: http://landley.net/writing/docs/cross-compiling.html
Host vs TargetA compiler is a program that turns source code into executable code. Like all programs, a compiler runs on">
<meta property="og:updated_time" content="2016-04-21T08:05:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Introduction to cross-compiling">
<meta name="twitter:description" content="refer: Original link
ref: http://landley.net/writing/docs/cross-compiling.html
Host vs TargetA compiler is a program that turns source code into executable code. Like all programs, a compiler runs on">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">sw-otaku</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://chenkc.github.io"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-introduction-to-cross-compiling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Introduction to cross-compiling
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/introduction-to-cross-compiling/" class="article-date">
  <time datetime="2016-03-02T04:48:41.000Z" itemprop="datePublished">2016-03-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>refer: <a href="http://landley.net/writing/docs/cross-compiling.html" target="_blank" rel="external">Original link</a></p>
<p>ref: <a href="http://landley.net/writing/docs/cross-compiling.html" target="_blank" rel="external">http://landley.net/writing/docs/cross-compiling.html</a></p>
<h2 id="Host-vs-Target"><a href="#Host-vs-Target" class="headerlink" title="Host vs Target"></a>Host vs Target</h2><p>A compiler is a program that turns source code into executable code. Like all programs, a compiler runs on a specific type of computer, and the new programs it outputs also run on a specific type of computer.[^1]</p>
<p>The computer the compiler runs on is called the host, and the computer the new programs run on is called the target. When the host and target are the same type of machine, the compiler is a native compiler. When the host and target are different, the compiler is a cross compiler.[^2]</p>
<h2 id="Why-cross-compile"><a href="#Why-cross-compile" class="headerlink" title="Why cross-compile?"></a>Why cross-compile?</h2><p>In theory, a PC user who wanted to build programs for some device could get the appropriate target hardware (or emulator), boot a Linux distro on that, and compile natively within that environment. While this is a valid approach (and possibly even a good idea when dealing with something like a Mac Mini), it has a few prominent downsides for things like a linksys router or iPod:</p>
<ul>
<li><p>Speed - Target platforms are usually much slower than hosts, by an order of magnitude or more. Most special-purpose embedded hardware is designed for low cost and low power consumption, not high performance. Modern emulators (like qemu) are actually faster than a lot of the real world hardware they emulate, by virtue of running on high-powered desktop hardware.[^3]</p>
</li>
<li><p>Capability - Compiling is very resource-intensive. The target platform usually doesn’t have gigabytes of memory and hundreds of gigabytes of disk space the way a desktop does; it may not even have the resources to build “hello world”, let alone large and complicated packages.</p>
</li>
<li><p>Availability - Bringing Linux up on a hardware platform it’s never run on before requires a cross-compiler. Even on long-established platforms like Arm or Mips, finding an up-to-date full-featured prebuilt native environment for a given target can be hard. If the platform in question isn’t normally used as a development workstation, there may not be a recent prebuilt distro readily available for it, and if there is it’s probably out of date. If you have to build your own distro for the target before you can build on the target, you’re back to cross-compiling anyway.</p>
</li>
<li><p>Flexibility - A fully capable Linux distribution consists of hundreds of packages, but a cross-compile environment can depend on the host’s existing distro from most things. Cross compiling focuses on building the target packages to be deployed, not spending time getting build-only prerequisites working on the target system.</p>
</li>
<li><p>Convenience - The user interface of headless boxes tends to be a bit crampled. Diagnosing build breaks is frustrating enough as it is. Installing from CD onto a machine that hasn’t got a CD-ROM drive is a pain. Rebooting back and forth between your test environment and your development environment gets old fast, and it’s nice to be able to recover from accidentally lobotomizing your test system.</p>
</li>
</ul>
<h2 id="Why-is-cross-compiling-hard"><a href="#Why-is-cross-compiling-hard" class="headerlink" title="Why is cross-compiling hard?"></a>Why is cross-compiling hard?</h2><h3 id="Portable-native-compiling-is-hard"><a href="#Portable-native-compiling-is-hard" class="headerlink" title="Portable native compiling is hard."></a>Portable native compiling is hard.</h3><p>Most programs are developed on x86 hardware, where they are compiled natively. This means cross-compiling runs into two types of problems: problems with the programs themselves and problems with the build system.</p>
<p>The first type of problem affects all non-x86 targets, both for native and for cross-builds. Most programs make assumptions about the type of machine they run on, which must match the platform in question or the program won’t work. Common assumptions include:</p>
<ul>
<li><p>Word size - Copying a pointer into an int may lose data on a 64 bit platform, and determining the size of a malloc by multiplying by 4 instead of sizeof(long) isn’t good either. Subtle security flaws due to integer overflows are also possible, ala “if (x+y &lt; size) memset(src+x,0,y);”, which results in a 4 gigabyte memset on 32-bit hardware when x=1000 and y=0xFFFFFFF0…</p>
</li>
<li><p>Endianness - Different systems store binary data iternally in different ways, which means that block-reading int or float data from disk or the network may need translation. Type “man byteorder” for details.</p>
</li>
<li><p>Alignment - Some platforms (such as arm) can only read or write ints from addresses that are an even multiple of 4 bytes, otherwise they segfault. Even the ones that can handle arbitrary alignments are slower dealing with unaligned data (they have to fetch twice to get both halves), so the compiler will often pad structures to align variables. Treating structures as a lump of data that can be sent to disk or across the network thus requires extra work to ensure a consistent representation.</p>
</li>
<li><p>Default signedness - Whether the “char” data type defaults to signed or unsigned varies from platform to platform (and in some cases from compiler to compiler), which can cause some really surprising bugs. The easy workaround for this is to provide a compiler argument like “-funsigned-char” to force the default to a known value.</p>
</li>
<li><p>NOMMU - If your target platform doesn’t have a memory management unit, several things need to change. You need vfork() instead of fork(), only certain types of mmap() work (shared or read only, but not copy on write), and the stack doesn’t grow dynamically.</p>
</li>
</ul>
<p>Most packages aim to be portable when compiled natively, and will at least accept patches to fix any of the above problems (with the possible exception of NOMMU issues) submitted to the appropriate development mailing list.</p>
<h3 id="And-then-there’s-cross-compiling"><a href="#And-then-there’s-cross-compiling" class="headerlink" title="And then there’s cross-compiling."></a>And then there’s cross-compiling.</h3><p>In addition to the problems of native compiling, cross-compiling has its own set of issues:</p>
<ul>
<li><p>Configuration issues - Packages with a separate configuration step (the “./configure” part of the standard configure/make/make install) often test for things like endianness or page size, to be portable when natively compiled. When cross-compiling, these values differ between the host system and the target system, so running tests on the host system gives the wrong answers. Configuration can also detect the presence of a package on the host and include support for it, when the target doesn’t have that package or has an incompatible version.</p>
</li>
<li><p>HOSTCC vs TARGETCC - Many build processes require compiling things to run on the host system, such as the above configuration tests, or programs that generate code (such as a C program that creates a .h file which is then #included during the main build). Simply replacing the host compiler with a target compiler breaks packages that need to build things that run during the build itself. Such packages need access to both a host and a target compiler, and need to be taught when to use each one. [^4]</p>
</li>
<li><p>Toolchain Leaks - An improperly configured cross-compile toolchain may leak bits of the host system into the compiled programs, resulting in failures that are usually easy to detect but which can be difficult to diagnose and correct. The toolchain may #include the wrong header files, or search the wrong library paths at link time. Shared libraries often depend on other shared libraries which can also sneak in unexpected link-time references to the host system.</p>
</li>
<li><p>Libraries - Dynamically linked programs must access the appropriate shared libraries at compile time. Shared libraries to the target system need to be added to the cross-compile toolchain so programs can link against them.</p>
</li>
<li><p>Testing - On native builds, the development system provides a convenient testing environment. When cross-compiling, confirming that “hello world” built successfully can require configuring (at least) a bootloader, kernel, root file system, and shared libraries.</p>
</li>
</ul>
<p>[^1]: The most prominent difference between types of computers is what processor is executing the programs, but other differences include library ABIs (such as glibc vs uClibc), machines with configurable endianness (arm vs armeb), or different modes of machines that can run both 32 bit and 64 bit code (such as x86 on x86-64).</p>
<p>[^2]: When building compilers, there’s a third type called a “canadian cross”, which is a cross compiler that doesn’t run on your host system. A canadian cross builds a compiler that runs on one target platform and produces code for another target machine. Such a foreign compiler can be built by first creating a temporary cross compiler from the host to the first target, and then using that to build another cross-compiler for the second target. The first cross-compiler’s target becomes the host the new compiler runs on, and the second target is the platform the new compiler generates output for. This technique is often used to cross-compile a new native compiler for a target platform.</p>
<p>[^3]: Modern desktop systems are sufficiently fast that emulating a target and natively compiling under the emulator is actually a viable strategy. It’s significantly slower than cross compiling, requires finding or generating a native build environment for the target (often meaning you have to set up a cross-compiler anyway), and can be tripped up by differences between the emulator and the real hardware to deploy on. But it’s an option.</p>
<p>[^4]: This is why cross-compile toolchains tend to prefix the names of their utilities, ala “armv5l-linux-gcc”. If that was simply called “gcc” then the host and native compiler couldn’t be in the $PATH at the same time.</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cross-compile/">cross compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/android-usb-tethering/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          Android USB Tethering
        
      </div>
    </a>
  
  
    <a href="/first-post/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">The-first-post&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 i.am.chenkc&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>